<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Rx4DDS : Reactive Extensions Adapters for RTI Connext DDS">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Rx4DDS</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rticommunity/rticonnextdds-reactive">View on GitHub</a>

          <h1 id="project_title">Rx4DDS</h1>
          <h2 id="project_tagline">Reactive Extensions Adapters for RTI Connext DDS</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rticommunity/rticonnextdds-reactive/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rticommunity/rticonnextdds-reactive/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><img src="https://rtidds.files.wordpress.com/2014/03/rx3dds.png" alt="Rx4DDS"></p>

<h3>
<a id="whats-rx4dds" class="anchor" href="#whats-rx4dds" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's Rx4DDS</h3>

<p>Rx4DDS is a research library that integrates Reactive Extensions (Rx) with RTI Connext DDS in C++11, C#, and JavaScript. Rx and DDS are quite complementary because Rx is based on the Observable-Observer pattern, which is analogous to the publish-subscribe pattern of DDS. Furthermore, the core tenet of Rx composition of operations over values that change over time complements DDS instances, which are data objects that change over time. DDS ensures propagation of changes to the interested remote participants. Consequently, combining Rx with DDS enables a coherent end-to-end distributed asynchronous dataflow architecture for both data distribution (which is performed by DDS) and processing (which is done by Rx). Rx and DDS together support location transparency of dataflow-style programs seamlessly. The resulting applications dramatically simplify concurrency to the extent that it can be simply configured.</p>

<h3>
<a id="status" class="anchor" href="#status" aria-hidden="true"><span class="octicon octicon-link"></span></a>Status</h3>

<p>The Rx4DDS adapters are research prototypes. RxJS adapter works with RTI Connext DDS Node.js Connector. The C# codebase also includes an implementation of the <a href="http://www.orgs.ttu.edu/debs2013/index.php?goto=cfchallengedetails">DEBS'13 Grand Challenge</a> using DDS and Rx.NET.</p>

<h3>
<a id="further-reading" class="anchor" href="#further-reading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Further Reading</h3>

<ul>
<li>DEBS'15 Research paper <a href="https://community.rti.com/paper/reactive-stream-processing-data-centric-publishsubscribe">Functional Reactive Stream Processing for Data-centric Publish/Subscribe</a>
</li>
<li>DEBS'15 Research paper <a href="https://community.rti.com/presentation/reactive-stream-processing-data-centric-publishsubscribe">presentation</a>
</li>
<li>A slightly older research paper <a href="http://community.rti.com/paper/scalable-reactive-stream-processing-using-dds-and-rx">Scalable Reactive Stream Processing Using DDS and Rx</a> </li>
<li>Silicon Valley Code Camp <a href="http://www.slideshare.net/SumantTambe/reactive-stream-processing-using-dds-and-rx">presentation</a>
</li>
<li>Silicon Valley Code Camp <a href="https://vimeo.com/108753792">video</a>
</li>
<li>First Rx4DDS.NET <a href="http://blogs.rti.com/2014/04/09/reactive-programming-using-rx4dds/">blogpost</a>
</li>
<li><a href="http://portals.omg.org/dds/">OMG DDS portal</a></li>
<li><a href="https://www.rti.com/products/dds">RTI Connext DDS</a></li>
<li><a href="https://www.youtube.com/user/RealTimeInnovations">RTI YouTube Channel</a></li>
</ul>

<h3>
<a id="data-transformation-using-map" class="anchor" href="#data-transformation-using-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Transformation using Map</h3>

<p>Demonstrates a stateful transformation pipeline. Transforms "Square" topic to "Circle" and "Triangle" topics. Blue circle orbits around the square, and blue triangle orbits around the blue circle. </p>

<p><iframe width="420" height="315" src="https://www.youtube.com/embed/mHNyEPeOPHg" frameborder="0" allowfullscreen></iframe></p>

<div class="highlight highlight-source-c++"><pre>  rx4dds::TopicSubscription&lt;ShapeType&gt; 
      <span class="pl-en">topic_sub</span>(participant, <span class="pl-s"><span class="pl-pds">"</span>Square<span class="pl-pds">"</span></span>, waitset, worker);
  rx::observable&lt;LoanedSample&lt;ShapeType&gt;&gt; source =
      topic_sub.create_observable();
  rx::observable&lt;ShapeType&gt; square_track = 
    source &gt;&gt; <span class="pl-en">rx4dds::complete_on_dispose</span>()
           &gt;&gt; rx4dds::error_on_no_alive_writers()
           &gt;&gt; filter([](LoanedSample&lt;ShapeType&gt; s) {
                 <span class="pl-k">return</span> s.<span class="pl-c1">info</span>().<span class="pl-c1">valid</span>();
              }) <span class="pl-c">// skip invalid samples</span>
           &gt;&gt; <span class="pl-en">map</span>([](LoanedSample&lt;ShapeType&gt; valid) {
                 <span class="pl-k">return</span> valid.<span class="pl-c1">data</span>();
              }); <span class="pl-c">// map samples to data</span>

  <span class="pl-k">int</span> circle_degree = <span class="pl-c1">0</span>;
  square_track
    .map([circle_degree](ShapeType &amp; square) <span class="pl-k">mutable</span> 
    {
      circle_degree = (circle_degree + <span class="pl-c1">3</span>) % <span class="pl-c1">360</span>;
      <span class="pl-k">return</span> <span class="pl-c1">shape_location</span>(square, circle_degree);
    })
    .tap([circle_writer](ShapeType &amp; circle) <span class="pl-k">mutable</span> {
            circle_writer.<span class="pl-c1">write</span>(circle);
    }); <span class="pl-c">// tap replaced as publish_over_dds later</span>

  <span class="pl-k">int</span> tri_degree = <span class="pl-c1">0</span>;
  circle_track
    .map([tri_degree](ShapeType &amp; circle) <span class="pl-k">mutable</span> 
    {
      tri_degree = (tri_degree + <span class="pl-c1">9</span>) % <span class="pl-c1">360</span>;
      <span class="pl-k">return</span> <span class="pl-c1">shape_location</span>(circle, tri_degree);
    })
    &gt;&gt; <span class="pl-en">rx4dds::publish_over_dds</span>(triangle_writer);

  triangle_track.subscribe();</pre></div>

<h3>
<a id="keyed-data-transformation-using-groupby-and-map" class="anchor" href="#keyed-data-transformation-using-groupby-and-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keyed Data Transformation using GroupBy and Map</h3>

<p>Demonstrates multiple parallel stateful pipelines. Same as before but the transformation pipeline is replicated for each key (i.e., shape color). The resulting topics ("Circle" and "Triangle") mimic the lifecycle of the original instance in "Square" topic. DDS dispose maps to on_completed and NOT_ALIVE_NO_WRITERS instance-state maps to on_error.</p>

<p><iframe width="420" height="315" src="https://www.youtube.com/embed/2Pz91e7yR5I" frameborder="0" allowfullscreen></iframe></p>

<div class="highlight highlight-source-c++"><pre>rx4dds::TopicSubscription&lt;ShapeType&gt; 
    <span class="pl-en">topic_sub</span>(participant, <span class="pl-s"><span class="pl-pds">"</span>Square<span class="pl-pds">"</span></span>, waitset, worker);
<span class="pl-k">auto</span> grouped_stream =
  topic_sub.create_observable() 
      &gt;&gt; <span class="pl-en">rx4dds::group_by_instance</span> ([](ShapeType &amp; shape) { 
            <span class="pl-k">return</span> shape.<span class="pl-c1">color</span>(); 
         });
grouped_stream
  .flat_map([circle_writer, triangle_writer]
            (GroupedShapeObservable go) {
   rx::observable&lt;ShapeType&gt; inner_transformed =
        go &gt;&gt; <span class="pl-c1">rx4dds::to_unkeyed</span>()
           &gt;&gt; <span class="pl-c1">rx4dds::complete_on_dispose</span>()
           &gt;&gt; <span class="pl-c1">rx4dds::error_on_no_alive_writers</span>()
           &gt;&gt; <span class="pl-c1">rx4dds::skip_invalid_samples</span>()
           &gt;&gt; <span class="pl-c1">rx4dds::map_samples_to_data</span>()
           &gt;&gt; <span class="pl-c1">rx4dds::map_to_circle_track</span>() <span class="pl-c">// as shown before</span>
           &gt;&gt; <span class="pl-c1">rx4dds::publish_over_dds</span>(
                 circle_writer, <span class="pl-c1">ShapeType</span>(go.<span class="pl-c1">key</span>())
           &gt;&gt; <span class="pl-c1">rx4dds::map_to_triangle_track</span>() <span class="pl-c">// as shown before</span>
           &gt;&gt; <span class="pl-c1">rx4dds::publish_over_dds</span>(
                 triangle_writer, <span class="pl-c1">ShapeType</span>(go.<span class="pl-c1">key</span>());
     <span class="pl-k">return</span> inner_transformed;
  }).subscribe();</pre></div>

<h3>
<a id="average-of-multiple-topic-instances" class="anchor" href="#average-of-multiple-topic-instances" aria-hidden="true"><span class="octicon octicon-link"></span></a>Average of Multiple Topic Instances</h3>

<p>Demonstrates dynamic correlation (average) of "Square" topic instances. Incorporates lifecycle (appearance and disappearance) of "Square" topic instances. As before, DDS dispose maps to on_completed and NOT_ALIVE_NO_WRITERS instance-state maps to on_error.</p>

<p><iframe width="420" height="315" src="https://www.youtube.com/embed/tZutExU6r0w" frameborder="0" allowfullscreen></iframe></p>


<div class="highlight highlight-source-c++"><pre>rx4dds::TopicSubscription&lt;ShapeType&gt; 
    <span class="pl-en">topic_sub</span>(participant, <span class="pl-s"><span class="pl-pds">"</span>Square<span class="pl-pds">"</span></span>, waitset, worker);
<span class="pl-k">auto</span> grouped_stream =
  topic_sub.create_observable() 
      &gt;&gt; <span class="pl-en">rx4dds::group_by_instance</span> ([](ShapeType &amp; shape) { 
            <span class="pl-k">return</span> shape.<span class="pl-c1">color</span>(); 
         });
grouped_stream
  .map([](GroupedShapeObservable go) {
    <span class="pl-k">return</span> go &gt;&gt; <span class="pl-c1">rx4dds::to_unkeyed</span>()
              &gt;&gt; <span class="pl-c1">rx4dds::complete_on_dispose</span>()
              &gt;&gt; <span class="pl-c1">rx4dds::error_on_no_alive_writers</span>()
              &gt;&gt; <span class="pl-c1">rx4dds::skip_invalid_samples</span>()
              &gt;&gt; <span class="pl-c1">rx4dds::map_samples_to_data</span>()
              &gt;&gt; <span class="pl-c1">publish</span>()
              &gt;&gt; <span class="pl-c1">ref_count</span>()
              &gt;&gt; <span class="pl-c1">as_dynamic</span>();
 })
 &gt;&gt; <span class="pl-en">rx4dds::coalesce_alive</span>()
 &gt;&gt; rxcpp::map([](<span class="pl-k">const</span> vector&lt;rxcpp::observable&lt;ShapeType&gt;&gt; &amp; srcs) {
      <span class="pl-k">return</span> <span class="pl-c1">rx4dds::combine_latest</span>(srcs);
    })
 &gt;&gt; <span class="pl-en">rxcpp::switch_on_next</span>()
 &gt;&gt; rxcpp::map([](<span class="pl-k">const</span> std::vector&lt;ShapeType&gt; &amp; shapes) {
         <span class="pl-k">return</span> <span class="pl-c1">calculate_average</span>(shapes);
    })
 &gt;&gt; <span class="pl-en">rx4dds::publish_over_dds</span>(triangle_writer, ShapeType(“ORANGE”));</pre></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Rx4DDS maintained by <a href="https://github.com/rticommunity">rticommunity</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
